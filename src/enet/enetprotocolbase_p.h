#ifndef ENETPROTOCOLBASE_P_H
#define ENETPROTOCOLBASE_P_H



#include <QObject>
#include <QHostAddress>
#include <QMutex>
#include <QThread>


#include "enet/include/enet/enet.h"

typedef unsigned int SOCKETID;

namespace HEHUI
{

class ENETProtocolBase;

class ENETProtocolBasePrivate : public QThread
{
    Q_OBJECT
public:
    explicit ENETProtocolBasePrivate(QObject *parent = 0);
    virtual ~ENETProtocolBasePrivate();

    bool isListening() const;
    bool getPeerAddressInfo(quint32 peerID, QString *address, quint16 *port);
    bool getLocalListeningAddressInfo(QString *address, quint16 *port);


    void setPeerPrivateData(quint32 peerID, void *data);
    void *getPeerPrivateData(quint32 peerID);

    QString errorString() const;

    struct OutgoingPacket{
        OutgoingPacket(ENetPeer *peer, ENetPacket *packet, quint8 channel = 0){
            this->peer = peer;
            this->packet = packet;
            this->channel = channel;
        }
        ENetPeer *peer;
        quint8 channel;
        ENetPacket *packet;
    };

signals:
    void connected(SOCKETID peerID, const QString &address, quint16 port);
    void disconnected(SOCKETID peerID, const QString &address, quint16 port);
    void dataReceived(SOCKETID peerID, QByteArray data);

public slots:
    //Start the server to listen,  implement the virtual function startWaitingForIO()
    bool listen(quint16 port, const QHostAddress &localAddress = QHostAddress::Any, unsigned int maximumNumberOfPeers = ENET_PROTOCOL_MAXIMUM_PEER_ID);
    //Close the server
    void close();

    //Call this function after server is listening
    void startWaitingForIOInAnotherThread(unsigned int msecWaitForIOTimeout = 10);
    void waitForIO(int msecTimeout = 20);

    //Connect to peer
    bool connectToHost(const QHostAddress &address, quint16 port, quint32 *peerID, unsigned int msecTimeout = 5000, quint32 channels = 0);

    //Send data
    bool sendData(ENetPeer *peer, const QByteArray *byteArray, bool reliable = true, quint8 channel = 0, bool queued = true);
    bool sendData(quint32 peerID, const QByteArray *byteArray, bool reliable = true, quint8 channel = 0, bool queued = true);
    bool sendPacket(OutgoingPacket *packet);

    //enet_host_flush
    void flush();

    //Close peer socket
    //No ENET_EVENT_DISCONNECT event will be generated
    void disconnectNow(quint32 peerID);

    //An ENET_EVENT_DISCONNECT event will be generated by enet_host_service() once the disconnection is complete.
    void disconnect(quint32 peerID);
    void disconnectLater(quint32 peerID);



protected:
    bool listen(ENetAddress *localListeningAddress = 0, unsigned int maximumNumberOfPeers = ENET_PROTOCOL_MAXIMUM_PEER_ID);

    void run();

private slots:


private:
    void msleep(int msec);

    void setPeerPrivateData(ENetPeer *peer, void *data);

    //Close peer socket
    void disconnectNow(ENetPeer *peer);
    void disconnect(ENetPeer *peer);
    void disconnectLater(ENetPeer *peer);

//    virtual void processReceivedData(quint32 peerID, QByteArray *data) = 0;

    void addPeer(quint32 peerID, ENetPeer *peer);
    void removePeer(quint32 peerID);
    quint32 getPeerID(ENetPeer *peer);
    ENetPeer *getPeer(quint32 peerID);


private:

    bool m_listening;
    int m_threadCount;

    int m_msecWaitForIOTimeout;

    ENetHost *localServer;

    QMutex mutex;
    //int m_peerID;
    QHash<quint32 /*Peer ID*/, ENetPeer *> peersHash;

    QString m_errorString;


    QList<OutgoingPacket> m_outgoingPacketList;


};

} //namespace HEHUI

#endif // ENETPROTOCOLBASE_P_H
